# üèóÔ∏è DA-KI Architektur-Dokumentation

## üìã √úbersicht

DA-KI implementiert eine moderne, modulare Architektur basierend auf dem **Teilprojekt-Konzept** mit klarer Trennung von Verantwortlichkeiten. Die Anwendung folgt einer **Service-orientierten Architektur (SOA)** mit REST-APIs und reaktiven Frontend-Komponenten.

## üéØ Teilprojekt-Architektur

```mermaid
graph TB
    subgraph "DA-KI Ecosystem"
        CORE[üß† CORE<br/>Berechnungen & KI]
        FRONTEND[üñ•Ô∏è FRONTEND<br/>User Interface]
        KI[ü§ñ KI-WACHSTUMSPROGNOSE<br/>Intelligence Layer]
        LIVE[üìä LIVE-MONITORING<br/>Real-time Operations]
        DEPO[üí∞ DEPO-STEUERUNG<br/>Portfolio Management]
    end
    
    CORE --> KI
    CORE --> LIVE
    CORE --> DEPO
    FRONTEND --> KI
    FRONTEND --> LIVE
    FRONTEND --> DEPO
    KI <--> LIVE
    LIVE <--> DEPO
```

### Teilprojekt-Details

| Teilprojekt | Verantwortlichkeiten | Technologien | Status |
|-------------|---------------------|--------------|---------|
| **CORE** | Basis-Algorithmen, Datenmodelle, Utils | Python, SQLite, Pandas | ‚úÖ Produktiv |
| **FRONTEND** | UI/UX, Dashboards, User Interactions | Dash, Plotly, HTML/CSS | ‚úÖ Produktiv |
| **KI-WACHSTUMSPROGNOSE** | ML-Modelle, Scoring-Algorithmen | Scikit-learn, NumPy | ‚úÖ Implementiert |
| **LIVE-MONITORING** | Real-time Data, WebSockets | AsyncIO, WebSockets | üöß Enhanced |
| **DEPO-STEUERUNG** | Portfolio-Optimierung, Trading | Optimization Libs | üìã Geplant |

## üèõÔ∏è System-Architektur

### High-Level Architecture

```mermaid
graph TB
    subgraph "Client Layer"
        UI[üñ•Ô∏è Web Dashboard<br/>Dash Frontend]
        API_CLIENT[üì± API Clients<br/>External Integrations]
    end
    
    subgraph "API Layer"
        API[üöÄ FastAPI Server<br/>REST Endpoints]
        WS[üîÑ WebSocket Handler<br/>Real-time Updates]
    end
    
    subgraph "Service Layer"
        GROWTH[ü§ñ Growth Prediction<br/>KI-Algorithmen]
        MONITOR[üìä Live Monitoring<br/>Position Tracking]
        PORTFOLIO[üí∞ Portfolio Service<br/>Optimization]
    end
    
    subgraph "Data Layer"
        DB[(üóÑÔ∏è SQLite Database<br/>Persistent Storage)]
        CACHE[‚ö° Redis Cache<br/>Performance Layer]
        EXT[üåê External APIs<br/>Market Data]
    end
    
    UI --> API
    API_CLIENT --> API
    API --> WS
    API --> GROWTH
    API --> MONITOR
    API --> PORTFOLIO
    GROWTH --> DB
    MONITOR --> DB
    PORTFOLIO --> DB
    GROWTH --> CACHE
    MONITOR --> CACHE
    MONITOR --> EXT
```

### Component Interaction

```mermaid
sequenceDiagram
    participant U as User
    participant F as Frontend
    participant A as API
    participant S as Service
    participant D as Database
    
    U->>F: Klick "Zu Live-Monitoring"
    F->>F: Zeige Position Modal
    U->>F: Eingabe (Aktien, Investment)
    F->>A: POST /api/live-monitoring/add
    A->>S: Verarbeite Position
    S->>D: Speichere Position
    D-->>S: Position ID
    S-->>A: Position Details
    A-->>F: Success Response
    F-->>U: Best√§tigung anzeigen
```

## üìÅ Datei-Organisation

### Directory Structure

```
DA-KI/
‚îú‚îÄ‚îÄ üìÅ api/                           # API Layer
‚îÇ   ‚îú‚îÄ‚îÄ api_top10_final.py           # Haupt-API Server
‚îÇ   ‚îú‚îÄ‚îÄ endpoints/                   # Modularisierte Endpoints
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ wachstumsprognose.py    # Growth Prediction APIs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ monitoring.py           # Live Monitoring APIs  
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ portfolio.py            # Portfolio Management APIs
‚îÇ   ‚îî‚îÄ‚îÄ middleware/                  # API Middleware
‚îÇ       ‚îú‚îÄ‚îÄ auth.py                 # Authentication
‚îÇ       ‚îú‚îÄ‚îÄ cache.py                # Caching Layer
‚îÇ       ‚îî‚îÄ‚îÄ cors.py                 # CORS Configuration
‚îú‚îÄ‚îÄ üìÅ frontend/                     # Frontend Layer
‚îÇ   ‚îú‚îÄ‚îÄ dashboard_top10.py          # Haupt-Dashboard
‚îÇ   ‚îú‚îÄ‚îÄ components/                 # UI Components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ growth_cards.py         # Wachstums-Karten
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ monitoring_table.py     # Live-Monitoring Tabelle
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ portfolio_simulator.py  # Portfolio-Simulation
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ modals.py               # Modal Dialoge
‚îÇ   ‚îú‚îÄ‚îÄ layouts/                    # Layout Templates
‚îÇ   ‚îî‚îÄ‚îÄ assets/                     # Static Assets (CSS, JS)
‚îú‚îÄ‚îÄ üìÅ services/                     # Service Layer
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ growth_prediction_top10.py  # KI-Wachstumsprognose
‚îÇ   ‚îú‚îÄ‚îÄ live_monitoring.py          # Live-Monitoring Service
‚îÇ   ‚îú‚îÄ‚îÄ portfolio_optimizer.py      # Portfolio-Optimierung
‚îÇ   ‚îú‚îÄ‚îÄ data_manager.py             # Datenverarbeitung
‚îÇ   ‚îî‚îÄ‚îÄ external_apis/              # External API Integrations
‚îÇ       ‚îú‚îÄ‚îÄ yahoo_finance.py
‚îÇ       ‚îú‚îÄ‚îÄ google_search.py
‚îÇ       ‚îî‚îÄ‚îÄ market_data.py
‚îú‚îÄ‚îÄ üìÅ database/                     # Data Layer
‚îÇ   ‚îú‚îÄ‚îÄ aktienanalyse_de.db         # SQLite Hauptdatenbank
‚îÇ   ‚îú‚îÄ‚îÄ schemas/                    # Database Schemas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ wachstumsprognosen.sql
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ live_monitoring.sql
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ portfolio.sql
‚îÇ   ‚îú‚îÄ‚îÄ migrations/                 # Database Migrations
‚îÇ   ‚îî‚îÄ‚îÄ seeders/                    # Test Data
‚îú‚îÄ‚îÄ üìÅ tests/                       # Test Suite
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ test_api/                   # API Tests
‚îÇ   ‚îú‚îÄ‚îÄ test_services/              # Service Tests
‚îÇ   ‚îú‚îÄ‚îÄ test_frontend/              # Frontend Tests
‚îÇ   ‚îî‚îÄ‚îÄ integration/                # Integration Tests
‚îú‚îÄ‚îÄ üìÅ docs/                        # Documentation
‚îÇ   ‚îú‚îÄ‚îÄ ARCHITECTURE.md             # Diese Datei
‚îÇ   ‚îú‚îÄ‚îÄ API.md                      # API Dokumentation
‚îÇ   ‚îú‚îÄ‚îÄ DEPLOYMENT.md               # Deployment Guide
‚îÇ   ‚îî‚îÄ‚îÄ DEVELOPMENT.md              # Development Guide
‚îú‚îÄ‚îÄ üìÅ scripts/                     # Utility Scripts
‚îÇ   ‚îú‚îÄ‚îÄ setup.py                   # Setup Script
‚îÇ   ‚îú‚îÄ‚îÄ migrate.py                 # Database Migration
‚îÇ   ‚îî‚îÄ‚îÄ seed_data.py               # Data Seeding
‚îî‚îÄ‚îÄ üìÅ config/                      # Configuration
    ‚îú‚îÄ‚îÄ development.py
    ‚îú‚îÄ‚îÄ production.py
    ‚îî‚îÄ‚îÄ testing.py
```

## üîÑ Data Flow Architecture

### Wachstumsprognose Flow

```mermaid
flowchart TD
    START[User Request] --> CACHE{Cache Check}
    CACHE -->|Hit| RETURN[Return Cached Data]
    CACHE -->|Miss| FETCH[Fetch Stock Data]
    FETCH --> CALC[Calculate 5-Factor Score]
    CALC --> RANK[Rank Top 10]
    RANK --> STORE[Store in Database]
    STORE --> CACHE_SET[Update Cache]
    CACHE_SET --> RETURN
    RETURN --> END[Display to User]
```

### Live-Monitoring Flow

```mermaid
flowchart TD
    USER[User Adds Position] --> MODAL[Position Modal]
    MODAL --> VALIDATE[Validate Input]
    VALIDATE --> API[API Call]
    API --> PRICE[Get Current Price]
    PRICE --> CALC[Calculate Values]
    CALC --> STORE[Store Position]
    STORE --> UPDATE[Update Dashboard]
    UPDATE --> NOTIFY[User Notification]
    
    subgraph "Background Process"
        TIMER[60s Timer] --> REFRESH[Refresh Prices]
        REFRESH --> UPDATE_DB[Update Database]
        UPDATE_DB --> PUSH[Push to Frontend]
    end
```

## üíæ Database Design

### Entity Relationship Diagram

```mermaid
erDiagram
    WACHSTUMSPROGNOSEN {
        int id PK
        string symbol
        float wachstums_score
        float prognostizierter_preis
        float erwartete_rendite
        string vertrauen_level
        string risiko_level
        datetime erstellt_am
    }
    
    LIVE_MONITORING_POSITIONS {
        int id PK
        string symbol
        int shares
        float investment_amount
        float entry_price
        float current_price
        float total_value
        float profit_loss
        float profit_loss_percent
        datetime added_at
        datetime last_updated
    }
    
    HISTORICAL_STOCK_DATA {
        int id PK
        string symbol
        float price
        float volume
        datetime timestamp
    }
    
    PORTFOLIO_SIMULATIONS {
        int id PK
        float startkapital
        json allocation
        float expected_return
        datetime created_at
    }
    
    WACHSTUMSPROGNOSEN ||--o{ LIVE_MONITORING_POSITIONS : "symbol"
    LIVE_MONITORING_POSITIONS ||--o{ HISTORICAL_STOCK_DATA : "symbol"
```

### Database Schema Evolution

```sql
-- Version 1: Basic Schema
CREATE TABLE wachstumsprognosen (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    symbol TEXT NOT NULL,
    wachstums_score REAL NOT NULL,
    erstellt_am TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Version 2: Enhanced Live Monitoring  
CREATE TABLE live_monitoring_positions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    symbol TEXT NOT NULL,
    shares INTEGER NOT NULL,
    investment_amount REAL NOT NULL,
    entry_price REAL,
    current_price REAL,
    total_value REAL,
    profit_loss REAL,
    profit_loss_percent REAL,
    added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Version 3: Portfolio Management (Geplant)
CREATE TABLE portfolio_allocations (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    portfolio_id INTEGER,
    symbol TEXT NOT NULL,
    target_weight REAL NOT NULL,
    current_weight REAL,
    rebalance_threshold REAL DEFAULT 0.05
);
```

## üöÄ API Architecture

### REST API Design

```yaml
# OpenAPI 3.0 Schema
openapi: 3.0.0
info:
  title: DA-KI API
  version: 2.0.0
  description: Deutsche Aktienanalyse mit KI-Wachstumsprognose

paths:
  /api/wachstumsprognose/top10:
    get:
      summary: Top 10 Wachstumsaktien
      responses:
        200:
          description: Erfolgreiche Antwort
          content:
            application/json:
              schema:
                type: object
                properties:
                  top_10_wachstums_aktien:
                    type: array
                    items:
                      $ref: '#/components/schemas/WachstumsAktie'
                  cache_status:
                    type: string
                  n√§chste_aktualisierung:
                    type: string

  /api/live-monitoring/add:
    post:
      summary: Position hinzuf√ºgen
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PositionRequest'
      responses:
        201:
          description: Position erfolgreich hinzugef√ºgt
          
components:
  schemas:
    WachstumsAktie:
      type: object
      properties:
        symbol:
          type: string
        name:
          type: string
        wachstums_score:
          type: number
        current_price:
          type: number
        prognose_30_tage:
          $ref: '#/components/schemas/Prognose'
          
    PositionRequest:
      type: object
      required:
        - symbol
        - shares
        - investment
      properties:
        symbol:
          type: string
        shares:
          type: integer
          minimum: 1
        investment:
          type: number
          minimum: 0.01
```

### API Versioning Strategy

```python
# Version 1: /api/v1/...  (Legacy)
# Version 2: /api/...     (Current)
# Version 3: /api/v3/...  (Future)

@app.get("/api/v1/wachstumsprognose")  # Deprecated
@app.get("/api/wachstumsprognose/top10")  # Current
@app.get("/api/v3/growth/predictions")  # Future
```

## ‚ö° Performance Architecture

### Caching Strategy

```mermaid
graph TB
    REQUEST[API Request] --> L1{L1 Cache<br/>Memory}
    L1 -->|Hit| RETURN[Return Data]
    L1 -->|Miss| L2{L2 Cache<br/>Redis}
    L2 -->|Hit| STORE_L1[Store in L1]
    L2 -->|Miss| DB[(Database)]
    STORE_L1 --> RETURN
    DB --> STORE_L2[Store in L2]
    STORE_L2 --> STORE_L1
```

### Asynchronous Processing

```python
# AsyncIO Pattern f√ºr Parallel Processing
async def berechne_alle_aktien_parallel():
    tasks = []
    for symbol in aktien_liste:
        task = asyncio.create_task(berechne_einzelne_aktie(symbol))
        tasks.append(task)
    
    results = await asyncio.gather(*tasks, return_exceptions=True)
    return results

# WebSocket f√ºr Real-time Updates  
@app.websocket("/ws/live-monitoring")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    while True:
        # Send real-time updates
        data = await get_live_monitoring_data()
        await websocket.send_json(data)
        await asyncio.sleep(60)  # 60 second intervals
```

## üîê Security Architecture

### Authentication & Authorization

```mermaid
graph TB
    USER[User] --> AUTH[Authentication]
    AUTH --> JWT[JWT Token]
    JWT --> API[API Access]
    API --> RBAC[Role-Based Access]
    RBAC --> RESOURCE[Protected Resource]
```

### Security Measures

```python
# CORS Configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://10.1.1.110:8054"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Rate Limiting
@app.middleware("http")
async def rate_limit_middleware(request, call_next):
    # Implement rate limiting logic
    pass

# Input Validation
class PositionRequest(BaseModel):
    symbol: str = Field(..., regex="^[A-Z]{1,5}$")
    shares: int = Field(..., gt=0, le=10000)
    investment: float = Field(..., gt=0.01, le=1000000)
```

## üìä Monitoring & Observability

### Application Metrics

```python
# Prometheus Metrics Integration
from prometheus_client import Counter, Histogram, Gauge

api_requests_total = Counter('api_requests_total', 'Total API requests', ['method', 'endpoint'])
response_time_seconds = Histogram('response_time_seconds', 'Response time in seconds')
active_positions_gauge = Gauge('active_positions', 'Number of active monitoring positions')
```

### Logging Strategy

```python
import logging
import structlog

# Structured Logging
logger = structlog.get_logger()

@app.middleware("http")
async def logging_middleware(request, call_next):
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    
    logger.info(
        "api_request",
        method=request.method,
        url=str(request.url),
        status_code=response.status_code,
        process_time=process_time
    )
    return response
```

## üîÆ Future Architecture Considerations

### Microservices Evolution

```mermaid
graph TB
    subgraph "Current Monolith"
        MONO[DA-KI Application]
    end
    
    subgraph "Future Microservices"
        AUTH_SVC[üîê Auth Service]
        GROWTH_SVC[ü§ñ Growth Service]
        MONITOR_SVC[üìä Monitoring Service]
        PORTFOLIO_SVC[üí∞ Portfolio Service]
        NOTIFICATION_SVC[üì® Notification Service]
    end
    
    MONO -.-> AUTH_SVC
    MONO -.-> GROWTH_SVC
    MONO -.-> MONITOR_SVC
    MONO -.-> PORTFOLIO_SVC
    MONO -.-> NOTIFICATION_SVC
```

### Cloud-Native Deployment

```yaml
# Kubernetes Deployment Example
apiVersion: apps/v1
kind: Deployment
metadata:
  name: da-ki-api
spec:
  replicas: 3
  selector:
    matchLabels:
      app: da-ki-api
  template:
    metadata:
      labels:
        app: da-ki-api
    spec:
      containers:
      - name: api
        image: da-ki/api:latest
        ports:
        - containerPort: 8003
        env:
        - name: DATABASE_URL
          value: "postgresql://..."
        - name: REDIS_URL
          value: "redis://..."
```

### Event-Driven Architecture

```mermaid
graph TB
    EVENT_BUS[Event Bus<br/>Apache Kafka]
    
    GROWTH_SVC[Growth Service] --> EVENT_BUS
    EVENT_BUS --> MONITOR_SVC[Monitoring Service]
    EVENT_BUS --> PORTFOLIO_SVC[Portfolio Service]
    EVENT_BUS --> NOTIFICATION_SVC[Notification Service]
    
    EVENT_BUS --> ANALYTICS[Analytics Pipeline]
    EVENT_BUS --> AUDIT[Audit Logging]
```

## üìã Architecture Decision Records (ADRs)

### ADR-001: Teilprojekt-basierte Architektur
- **Status**: Accepted
- **Context**: Modulare Entwicklung und klare Verantwortlichkeiten
- **Decision**: 5-Teilprojekt Struktur (CORE, FRONTEND, KI, LIVE, DEPO)
- **Consequences**: Bessere Skalierbarkeit, einfachere Wartung

### ADR-002: SQLite als prim√§re Datenbank
- **Status**: Accepted  
- **Context**: Einfache Deployment, ausreichende Performance f√ºr MVP
- **Decision**: SQLite f√ºr lokale Entwicklung, Migration zu PostgreSQL geplant
- **Consequences**: Schnelle Entwicklung, sp√§tere Migration erforderlich

### ADR-003: FastAPI + Dash Framework
- **Status**: Accepted
- **Context**: Moderne Python Web-Frameworks
- **Decision**: FastAPI f√ºr API, Dash f√ºr interaktive Dashboards
- **Consequences**: Hohe Entwicklungsgeschwindigkeit, Python-Konsistenz

---

**üìù Architektur-Dokumentation | Version 2.0 | DA-KI Project**

*Entwickelt mit [Claude Code](https://claude.ai/code) - Moderne KI-gest√ºtzte Softwareentwicklung*